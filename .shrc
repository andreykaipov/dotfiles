#!/bin/sh
# shellcheck source=/dev/null disable=SC2016,SC2046
#
# What should and should not go into this file? Well, since our local tmux
# session inherits the environment from the login shell that spawned it, any
# environment variables are available from within child tmux windows/panes too,
# so we don't need to source ~/.shenv here too. However, aliases and functions
# are not exportable, so we must source ~/.shalias and ~/.shfunction here. This
# is rather quick as functions and aliases defined via single quotes are lazily
# evaluated.
#
# But wait -- what happens if I want to update the environment during my tmux
# session? Shouldn't we also source ~/.shenv? No, because once everything is set
# up, the environment doesn't change often nor dynamically enough, so it doesn't
# merit exporting them as often as we create new tmux panes. However, when they
# they do change, it'd be very cumbersome relying on tmux inheriting the login
# shell's environment as it means us having to restart tmux and "logging in" all
# over again.
#
# Fortunately, there's a way around this! We can update tmux's global
# environment from within tmux itself. The `promote` function below does so.
# See https://stackoverflow.com/a/61882412/4085283 for more information.
#
# The workflow for updating environmental variables is to edit ~/.shenv as
# usual, and then run `promote ~/.shenv` instead of `. ~/.shenv` from the
# current shell. Any new tmux windows/panes will have our updated environment!
# This will also update the existing environment too, acting as a drop-in
# replacement for the `source` built-in.
#
# If we want to get really sophisticated in the future, we can set up a watch on
# ~/.shenv via inotify to run this function on changes to avoid doing so
# manually! But I'm not too crazy yet!
#
# By sourcing our file from a limited subshell, we avoid promoting any
# unnecessary env vars to the global tmux environment (e.g. we may have exported
# a one-time build env var that new shells don't need). Once we have every
# variable exported by the sourced file, we use indirect variable references to
# update our environment. The escaped quotes are necessary because of word
# splitting as values can potentially have leading/trailing spaces.
promote() {
    sourced="$1"; shift
    . "$sourced"
    env - \
        "HOME=$HOME" \
        "SHELL=$SHELL" \
        | sh -c ". $sourced; env" | cut -d= -f1 | while read -r var; do
            val="$(eval "echo \"\$$var\"")"
            tmux set-environment -gt local "$var" "$val"
        done
}

. "$HOME/.shalias"
. "$HOME/.shfunction"
. "$HOME/.git-prompt.sh"

# Non-printing chars have to be surrounded by \[...\]; otherwise Bash will
# improperly display the prompt especially when reverse searching. The \e[5 q at
# the end makes our cursor a blinking vertical line.
#
# path/to/whatever git-info
# ❯ vi ~/.shrc

__prompt_command() {
    retlastcmd="$?"
    if [ "$retlastcmd" = 0 ]; then
        retcolor="\[${_brightgreen?}\]"
    else
        retcolor="\[${_brightred?}\]"
    fi
    prompt="$retcolor❯\[${_reset?}\] \[\e[5 q\]"

    path="\[${_brightyellow?}\]\w\[${_reset?}\]"
    gitinfo="$(git_status_condensed "$@")"

    PS1="
$path $gitinfo
$prompt"
}

PROMPT_DIRTRIM=3
PROMPT_COMMAND=__prompt_command

###


#
# ┌[hh:mm:ss] [path/to/whatever] [n files, m bytes]
# └▶ vi ~/.shrc
# PS1="
# ┌[\$(if [ \$? = 0 ]; then echo '$_green\D{%T}$_reset'; else echo '$_red\D{%T}$_reset'; fi)] [$_brightyellow\w$_reset] \$(__git_ps1 '[$_brightpurple%s\e[0m] ')[$_blue\$(ls | wc -l) files, \$(ls -al | head -n1 | sed 's/total //')$_reset]
# └▶ "
