#!/bin/bash
# shellcheck shell=sh source=/dev/null
#
# What should and should not go into this file? Well, since our local tmux
# session inherits the environment from the login shell that spawned it, any
# environment variables are available from within child tmux windows/panes too,
# so we don't need to source ~/.shenv here too. However, aliases and functions
# are not exportable, so we must source ~/.shalias and ~/.shfunction here. This
# is rather quick as functions and aliases defined via single quotes are lazily
# evaluated.
#
# But wait -- what happens if I want to update the environment during my tmux
# session? Shouldn't we also source ~/.shenv? No, because once everything is set
# up, the environment doesn't change often nor dynamically enough, so it doesn't
# merit exporting them as often as we create new tmux panes. However, when they
# they do change, it'd be very cumbersome relying on tmux inheriting the login
# shell's environment as it means us having to restart tmux and "logging in" all
# over again.
#
# Fortunately, there's a way around this! We can update tmux's global
# environment from within tmux itself. The `promote` function below does so.
# See https://stackoverflow.com/a/61882412/4085283 for more information.
#
# The workflow for updating environmental variables is to edit ~/.shenv as
# usual, and then run `promote ~/.shenv` instead of `. ~/.shenv` from the
# current shell. Any new tmux windows/panes will have our updated environment!
# This will also update the existing environment too, acting as a drop-in
# replacement for the `source` built-in.
#
# If we want to get really sophisticated in the future, we can set up a watch on
# ~/.shenv via inotify to run this function on changes to avoid doing so
# manually! But I'm not too crazy yet!
#
# By sourcing our file from a limited subshell, we avoid promoting any
# unnecessary env vars to the global tmux environment (e.g. we may have exported
# a one-time build env var that new shells don't need). Once we have every
# variable exported by the sourced file, we use indirect variable references to
# update our environment. The escaped quotes are necessary because of word
# splitting as values can potentially have leading/trailing spaces.
#
# Known limitations involve completely removing variables from our sourced file.
# We'd have to remove any of those from the global tmux environment ourselves.
promote() {
    sourced="$1"; shift
    . "$sourced"
    env - \
        "HOME=$HOME" \
        | sh -c ". $sourced; env" | cut -d= -f1 | while read -r var; do
            val="$(eval "echo \"\$$var\"")"
            tmux set-environment -gt local "$var" "$val"
        done
}

. ~/.shalias
. ~/.shfunction
. ~/.shooks
. ~/local/share/bash-completion/bash_completion

: "${_reset?}" "${_brightred?}" "${_brightgreen?}" "${__ret_last_cmd:=0}"

# Fallback for anything but Bash. We use printf to print colors as not every
# shell supports colors directly in its PS1, e.g. ash or dash or any minimal
# shell. Why would we ever use ash or dash? Mind your own business.
if [ -z "$BASH_VERSION" ]; then
    # shellcheck disable=SC2016
    fnretcolor='if [ "$?" = 0 ]; then printf "${_brightgreen}"; else printf "${_brightred}"; fi'
    PS1='$(printf "$(eval "$fnretcolor")%s$_reset$ " "$0")'
    printf "\e]2;%s\e\\" "#[fg=yellow,bold]$PWD#[fg=default] $(git condensed-status-tmux)"
    return
fi


# Our prompt is a custom top-down Bash prompt, which keeps the prompt line at
# the very top, while still moving commands up in history using the tmux
# scrollback buffer. It is BEAUTIFULLY hacked together using ANSI/VT100 escape
# sequences (see http://www.termsys.demon.co.uk/vtansi.htm).
#
# The first line of our prompt is our working area where we type commands.
# The second line of our prompt is just a blank line for padding.
# The third line contains the running or previously ran command.
# Anything below these three lines is for stdout/stderr. Text larger than the
# remaining area will remain in history but the above three lines will cut off
# any interfering output.
#
# Now read through the precmds and postcmds to remember the gorgeous abomination
# you created Andrey. Hopefully you won't regret it (maybe in 5 years).
#
# Limitation: if we execute a multiline command, e.g. cat <<EOF ..., our input
# will collide with the output of the previous command. Maybe this can be fixed
# by playing around with our PS2 variable.
#
# Limitation: if we do tab completion, it conflicts with the output of the
# previous command.
#
# Note: Maybe we can hack auto pagers with something like
#    LAST="$(cat /tmp/x)"
#    exec >/dev/tty
#    exec > >(tee /tmp/x | less -FXr)

# precmd workflow:
# - We type a command into the prompt line to be executed.
# - We press <Enter> and their cursor is now at the next line.
# - The precmd hook fires.
# - We hop back up to our prompt line and erase the entire line (\e[H\e[2K),
#   hiding the prompt line from the tmux scrollback buffer.
# - We move down two lines (\e[2B) to the third line, so that when our
#   command is executed, its output can be printed at this line and below.
# - At this point we clear the entire screen (\e[2J), making the output of
#   the previous command available in the tmux scrollback.
# - Even though we cleared the screen, our cursor is at the same point. We
#   print a temporary neutrally-colored prompt glyph (❯❯) and the command to be
#   executed (yes it's already in the history even though we're still in the
#   precmd). Assign it to a variable since we use it again it the postcmd.
# - We print a fake prompt (see comments).
# - The precmd hook ends and our command is executed.
precmd() {
    printf "\e[H\e[2K"
    printf "\e[2B"
    printf "\e[2J"

    # The following flushes a new-line to our tmux scrollback buffer so that our
    # prompt line can stay padded in between already executed commands.
    # printf "\e[9999B\n"
    # printf "\e[2J"
    # printf "\e[H\e[2B"

    __lastcmd="$(HISTTIMEFORMAT='' history 1 | awk '$1~/^[0-9]+$/{$1=""}1')"
    printf "\e[1;33m❯❯\e[0m%s" "$__lastcmd"
    printf "\n"

    # The following adds a fake prompt glyph to our prompt line. Makes the
    # prompt still visible during long running commands, e.g. sleep 3, so the
    # overall UX is not jarring.
    printf "\e[H"
    printf "\e[1;33m❯\e[0m"
    printf "\e[2B"
    printf "\n"
}

# postcmd workflow:
# - Our command has finished executing. The postcmd hook fires.
# - The cursor is now somewhere on line 5 or below depending on how large the
#   output of the command was.
# - Remedy this by moving to the prompt line and clearing it. (\e[H\e[2K)
# - Do the same thing for the next two lines avoid very large outputs
#   conflicting with this line. (\e[1B\[e2K) x2
# - At the third line, recolor the prompt glyph(s) according to the exit status
#   of the command, by moving the cursor down one more line and rewriting it.
# - Move back up to the prompt line as that's the dedicated typing area.
postcmd() {
    printf "\e[H\e[2K"
    printf "\e[1B\e[2K"
    printf "\e[1B\e[2K"
    [ "$__ret_last_cmd" = 0 ] && color="32" || color="31"
    printf "\e[${color}m❯❯\e[0m%s" "$__lastcmd"
    printf "\e[H"
}

# Note: Don't forget to surround non-printing chars with \[...\] (Bash's PS1) or
# \1...\2 (readline). Otherwise, our prompt will display incorrectly during
# navigation with C-[AEUR], for example.
#
# For terminals supporting DECSCUSR sequences, we change our cursor between
# readline modes. See https://invisible-island.net/xterm/ctlseqs/ctlseqs.html.
setprompt() {
    PS1=' '
    promptcolor='\e[1;33m'
    bind "set emacs-mode-string  \1\e[5 q\2\1$promptcolor\2@\1$_reset\2"
    bind "set vi-ins-mode-string \1\e[5 q\2\1$promptcolor\2❯\1$_reset\2"
    bind "set vi-cmd-mode-string \1\e[6 q\2\1$promptcolor\2:\1$_reset\2"

    # Set tmux window and pane title. See
    # http://man7.org/linux/man-pages/man1/tmux.1.html#NAMES_AND_TITLES.
    # printf "\ek%s\e\\" "#[fg=yellow]$PWD#[fg=default]"
    printf "\e]2;%s\e\\" "#[fg=yellow,bold]${PWD/$HOME/'~'}#[fg=default] $(git condensed-status-tmux)"

    # readline_keymap="$(bind -v | awk '$2 == "keymap" {print $3}')"
}

main() {
    shopt -s autocd
    setprompt
    clear
}

# do the same for C-c and clearing,
# and \ee switching modes show as tmux pane title

### Multi-line commands ###
#
# e.g. ❯ cat <<EOF
#      | hi
#      | yo
#      | EOF
#
# If there's no previous output from a command, we're good. No text conflict.
# When there's previous output, there's two ways our multiline command can
# conflict. (1) We type it ourselves, or (2) we search through history for it.
#
# For (1), we can use PS2 to take care of this. Any time a new PS2 prompt
# appears, we just clear the entire and line place our actual PS2 glpyh.
#
# For (2), the solution is a bit of a hack (like this entire thing). Kinda
# coincidentally, I realized that when scrolling backwards through history, and
# I get to a multiline command, if I scroll forward once, it'll clear the
# conflicting text exactly how I want it to. So, just map our up key to do
# just this using temporary \C-t* bindings.

PS2='\[\e[2K\]|'
bind '"\C-t23": history-search-backward'
bind '"\C-t24": history-search-forward'
bind '"\e[A": "\C-t23\C-t24\C-t23"'

# Wrap complete functionality between two hooks (precomplete and postcomplete).
#
# workflow:
# - We press <Tab>, precomplete hook fires.
# - Before each completion, go to the prompt line.
# - Move the cursor down two lines and clear the line.
# - Print an extra neutral prompt glyph to indicate tab completion.
# - With our cursor here, tab completion happens at the third line and below.
# - Once the completion suggestions have been printed, go to the prompt line and
#   unset __precmd_start so that we rerun our precmd hook upon each completion.
#   This makes sure the precmd hook runs once we actually press <Enter> and not
#   just during the very first completion.

bind -x '"\C-t11": precomplete'
bind -x '"\C-t12": postcomplete'
bind    '"\C-t13": complete'
bind    '"\C-i": "\C-t11\C-t13\C-t12"'

precomplete() {
    printf "\e[H"
    printf "\e[2B\e[2K"
    printf "\e[1;33m❯\e[0m"
}

postcomplete() {
    printf "\e[H"
    unset __precmd_start
}

main

####

    # trap printprompt SIGWINCH
    # postcmd
    
# Outputs the coordinations of where the cursor currently is, for use with the
# \e[{row}:${column}f escape sequence.
get_cursor() {
    printf "\033[6n"
    read -srd\[ _
    read -srdR __ccoords
}

__prompt_command() {
    echo
    #path="\[${_brightyellow}\]\w\[${_reset}\]"
    #gitinfo="$(git condensed-status)"
    #PS1="\n$path $gitinfo\n "

    #mux set -g status-left "#S #P $PWD"
    #tmux set #{W:#{E:window-status-format} ,#{E:window-status-current-format} }
    #{W:#{E:window-status-format} ,#{E:window-status-current-format} }
    #~
    #tmux set -g window-status-current-format "
    #tmux rename-window "$PWD $(git condensed-status-tmux)"
}
